#include <string>
#include <iostream>
#include <vector>
#include <algorithm>
#include <fstream>
#if defined(_WIN32)
#include <direct.h>
#else
#include <sys/stat.h>
#endif
#include "json11.hpp"

using namespace json11;
using namespace std;

int main(int argc, char **argv)
{
	vector<string> all_identifier_names;

	// check command line args
	if (argc != 2)
	{
		cout << "Useage: " << argv[0] << " <config file> \n";
		exit(1);
	}
	std::ifstream json_file(argv[1]);
	if (!json_file.is_open())
	{
		cout << "Could not open input file" << argv[1] << ".\n";
		exit(1);
	}

	// read json config file
    json_file.seekg(0, std::ios::end);
    std::string str;
    str.reserve(json_file.tellg());
    json_file.seekg(0, std::ios::beg);
    str.assign((std::istreambuf_iterator<char>(json_file)),
                std::istreambuf_iterator<char>());

    // parse json config file
    string parse_error;
    const auto json = Json::parse(str, parse_error);
	if (parse_error != "")
	{
		cout << "There was a JSON parsing error: " << parse_error << "\n";
		exit(0);
	}

	// check target type
    if (json["TargetType"].string_value() == "")
    {
    	cout << "No target type specified\n";
    	exit(1);
    }
    if (json["TargetType"].string_value() != "Linux" && json["TargetType"].string_value() != "Windows")
	{
		cout << "Target type not supported\n";
		exit(1);
	}

    // check target name
    if (json["TargetName"].string_value() == "")
    {
    	cout << "No target name specified\n";
    	exit(1);
    }

	// check number of windows
	if (json["Windows"].array_items().size() == 0)
	{
		cout << "No windows found.\n";
		exit(1);
	}

    // make output folders
#if defined(_WIN32)
	if (_mkdir("generated") != 0 && errno != EEXIST)
	{
    	cout << "Could not make generated folder.\n";
    	exit(1);
	}
	if (_mkdir(std::string("generated\\" + json["TargetType"].string_value()).c_str()) != 0 && errno != EEXIST)
	{
    	cout << "Could not make generated\\" << json["TargetType"].string_value() << " folder.\n";
    	exit(1);
	}
	if (_mkdir(std::string("generated\\" + json["TargetType"].string_value() + "\\src").c_str()) != 0 && errno != EEXIST)
	{
    	cout << "Could not make generated\\" << json["TargetType"].string_value() << "\\src folder.\n";
    	exit(1);
	}
	if (_mkdir("generated\\common") != 0 && errno != EEXIST)
	{
    	cout << "Could not make generated\\common folder.\n";
    	exit(1);
	}
#elif defined(__linux__)
	if (mkdir("generated", 0777) != 0 && errno != EEXIST)
	{
    	cout << "Could not make generated folder.\n";
    	exit(1);
	}
	if (mkdir(std::string("generated/" + json["TargetType"].string_value()).c_str(), 0777) != 0 && errno != EEXIST)
	{
    	cout << "Could not make generated/" << json["TargetType"].string_value() << " folder.\n";
    	exit(1);
	}
	if (mkdir(std::string("generated/" + json["TargetType"].string_value() + "/src").c_str(), 0777) != 0 && errno != EEXIST)
	{
		cout << "Could not make generated/" << json["TargetType"].string_value() << "/src folder.\n";
		exit(1);
	}
	if (mkdir("generated/common", 0777) != 0 && errno != EEXIST)
	{
		cout << "Could not make generated/common folder.\n";
		exit(1);
	}
#endif

    // check large size flag
    bool large_size = json["LargeSize"].bool_value();

	// create miniwin_user.c
	std::ofstream outfileUserSource("generated/common/miniwin_user.c");
	if (!outfileUserSource.is_open())
	{
		cout << "Could not create file\n";
		exit(1);
	}
	
	// header comment
	outfileUserSource << "/* miniwin_user.c generated by MiniWin code generator. */\n\n";
	
	// include header files
	outfileUserSource << "#include \"miniwin.h\"\n";
	for (auto &window : json["Windows"].array_items())
    {
		outfileUserSource << "#include \"";
    	outfileUserSource << window["Name"].string_value() << ".h\"\n";
    }
	outfileUserSource << "\n";
	
	// menu arrays
	for (auto& window : json["Windows"].array_items())
    {
		if (window["MenuItems"].array_items().size() == 0)
		{
			continue;
		}

		all_identifier_names.push_back(window["Name"].string_value() + "_menu_bar_labels");
		outfileUserSource << "static const char *" << window["Name"].string_value() << "_menu_bar_labels[] = {";
		uint32_t i = 0;
	    for (auto &menu_item_label : window["MenuItems"].array_items())
	    {
	    	outfileUserSource << "\"";
	    	outfileUserSource << menu_item_label.string_value();
	    	outfileUserSource << "\"";
	    	if (i < window["MenuItems"].array_items().size() - 1)
	    	{
	    		outfileUserSource << ", ";
	    	}
	    	i++;
	    }
	    outfileUserSource << "};\n";
    }
	
	// radio button arrays
	for (auto& window : json["Windows"].array_items())
    {
		for (auto& radio_button : window["RadioButtons"].array_items())
		{
			if (radio_button["Labels"].array_items().size() == 0)
			{
				continue;
			}

			all_identifier_names.push_back("radio_button_" + radio_button["Name"].string_value() + "_labels");
			outfileUserSource << "static const char *radio_button_" << radio_button["Name"].string_value() << "_labels[] = {";
			uint32_t i = 0;
			for (auto &label : radio_button["Labels"].array_items())
			{
				outfileUserSource << "\"";
				outfileUserSource << label.string_value();
				outfileUserSource << "\"";
				if (i < radio_button["Labels"].array_items().size() - 1)
				{
					outfileUserSource << ", ";
				}
				i++;
			}
			outfileUserSource << "};\n";
		}
    }
    
    // list boxes arrays
	for (auto& window : json["Windows"].array_items())
    {
		for (auto& list_box : window["ListBoxes"].array_items())
		{
			if (list_box["Labels"].array_items().size() == 0)
			{
				continue;
			}

			all_identifier_names.push_back("list_box_" + list_box["Name"].string_value() + "_entries");
			outfileUserSource << "static const mw_ui_list_box_entry list_box_" << list_box["Name"].string_value() << "_entries[] = {";
			uint32_t i = 0;
			for (auto &label : list_box["Labels"].array_items())
			{
				outfileUserSource << "{\"";
				outfileUserSource << label.string_value();
				outfileUserSource << "\", NULL}";
				if (i < list_box["Labels"].array_items().size() - 1)
				{
					outfileUserSource << ", ";
				}
				i++;
			}
			outfileUserSource << "};\n";
		}
    }
        
	outfileUserSource << "\n";	

	// create window variables
    for (auto &window : json["Windows"].array_items())
    {
    	all_identifier_names.push_back("window_" + window["Name"].string_value() + "_handle");
        outfileUserSource << "mw_handle_t window_";
    	outfileUserSource << window["Name"].string_value() << "_handle;\n";
    }
   	outfileUserSource << "\n";
   	
   	// create controls handles
    for (auto &window : json["Windows"].array_items())
    {
		// create buttons handles
		for (auto& button : window["Buttons"].array_items())
		{
			all_identifier_names.push_back("button_" + button["Name"].string_value() + "_handle");
			outfileUserSource << "mw_handle_t button_" << button["Name"].string_value() << "_handle;\n";
		}
		// creats labels handles
		for (auto& label : window["Labels"].array_items())
		{
			all_identifier_names.push_back("label_" + label["Name"].string_value() + "_handle");
			outfileUserSource << "mw_handle_t label_" << label["Name"].string_value() << "_handle;\n";
		}		
		// creats check boxes handles
		for (auto& check_box : window["CheckBoxes"].array_items())
		{
			all_identifier_names.push_back("check_box_" + check_box["Name"].string_value() + "_handle");
			outfileUserSource << "mw_handle_t check_box_" << check_box["Name"].string_value() << "_handle;\n";
		}	
		// create arrows handles
		for (auto& arrow : window["Arrows"].array_items())
		{
			all_identifier_names.push_back("arrow_" + arrow["Name"].string_value() + "_handle");
			outfileUserSource << "mw_handle_t arrow_" << arrow["Name"].string_value() << "_handle;\n";
		}		
		// create progress bars handles
		for (auto& progress_bar : window["ProgressBars"].array_items())
		{
			all_identifier_names.push_back("progress_bar_" + progress_bar["Name"].string_value() + "_handle");
			outfileUserSource << "mw_handle_t progress_bar_" << progress_bar["Name"].string_value() << "_handle;\n";
		}				
		// create horiz scroll bars handles
		for (auto& scroll_bar_horiz : window["HorizScrollBars"].array_items())
		{
			all_identifier_names.push_back("scroll_bar_horiz_" + scroll_bar_horiz["Name"].string_value() + "_handle");
			outfileUserSource << "mw_handle_t scroll_bar_horiz_" << scroll_bar_horiz["Name"].string_value() << "_handle;\n";
		}			
		// create vert scroll bars handles
		for (auto& scroll_bar_vert : window["VertScrollBars"].array_items())
		{
			all_identifier_names.push_back("scroll_bar_vert_" + scroll_bar_vert["Name"].string_value() + "_handle");
			outfileUserSource << "mw_handle_t scroll_bar_vert_" << scroll_bar_vert["Name"].string_value() << "_handle;\n";
		}				
		// create radio buttons handles
		for (auto& radio_button : window["RadioButtons"].array_items())
		{
			all_identifier_names.push_back("radio_button_" + radio_button["Name"].string_value() + "_handle");
			outfileUserSource << "mw_handle_t radio_button_" << radio_button["Name"].string_value() << "_handle;\n";
		}	
		// create list boxes handles
		for (auto& list_box : window["ListBoxes"].array_items())
		{
			all_identifier_names.push_back("list_box_" + list_box["Name"].string_value() + "_handle");
			outfileUserSource << "mw_handle_t list_box_" << list_box["Name"].string_value() << "_handle;\n";
		}									
	}
	outfileUserSource << "\n";
    
    // create controls data
    for (auto &window : json["Windows"].array_items())
    {
		// creat buttons data
		for (auto& button : window["Buttons"].array_items())
		{
			all_identifier_names.push_back("button_" + button["Name"].string_value() + "_data");
			outfileUserSource << "static mw_ui_button_data_t button_" << button["Name"].string_value() << "_data;\n";
		}
		// creat labels data
		for (auto& label : window["Labels"].array_items())
		{
			all_identifier_names.push_back("label_" + label["Name"].string_value() + "_data");
			outfileUserSource << "static mw_ui_label_data_t label_" << label["Name"].string_value() << "_data;\n";
		}		
		// create check boxes data
		for (auto& check_box : window["CheckBoxes"].array_items())
		{
			all_identifier_names.push_back("check_box_" + check_box["Name"].string_value() + "_data");
			outfileUserSource << "static mw_ui_check_box_data_t check_box_" << check_box["Name"].string_value() << "_data;\n";
		}	
		// create arrows data
		for (auto& arrow : window["Arrows"].array_items())
		{
			all_identifier_names.push_back("arrow_" + arrow["Name"].string_value() + "_data");
			outfileUserSource << "static mw_ui_arrow_data_t arrow_" << arrow["Name"].string_value() << "_data;\n";
		}		
		// create progress bars data
		for (auto& progress_bar : window["ProgressBars"].array_items())
		{
			all_identifier_names.push_back("progress_bar_" + progress_bar["Name"].string_value() + "_data");
			outfileUserSource << "static mw_ui_progress_bar_data_t progress_bar_" << progress_bar["Name"].string_value() << "_data;\n";
		}	
		// create horiz scroll bars data
		for (auto& scroll_bar_horiz : window["HorizScrollBars"].array_items())
		{
			all_identifier_names.push_back("scroll_bar_horiz_" + scroll_bar_horiz["Name"].string_value() + "_data");
			outfileUserSource << "static mw_ui_scroll_bar_horiz_data_t scroll_bar_horiz_" << scroll_bar_horiz["Name"].string_value() << "_data;\n";
		}			
		// create vert scroll bars data
		for (auto& scroll_bar_vert : window["VertScrollBars"].array_items())
		{
			all_identifier_names.push_back("scroll_bar_vert_" + scroll_bar_vert["Name"].string_value() + "_data");
			outfileUserSource << "static mw_ui_scroll_bar_vert_data_t scroll_bar_vert_" << scroll_bar_vert["Name"].string_value() << "_data;\n";
		}		
		// create radio buttons data
		for (auto& radio_button : window["RadioButtons"].array_items())
		{
			all_identifier_names.push_back("radio_button_" + radio_button["Name"].string_value() + "_data");
			outfileUserSource << "static mw_ui_radio_button_data_t radio_button_" << radio_button["Name"].string_value() << "_data;\n";
		}		
		// create list boxes data
		for (auto& list_box : window["ListBoxes"].array_items())
		{
			all_identifier_names.push_back("list_box_" + list_box["Name"].string_value() + "_data");
			outfileUserSource << "static mw_ui_list_box_data_t list_box_" << list_box["Name"].string_value() << "_data;\n";
		}										
	}
    
    // root functions and user_init function start
    outfileUserSource << "\nvoid mw_user_root_paint_function(const mw_gl_draw_info_t *draw_info)\n" \
						 "{\n    mw_gl_set_solid_fill_colour(MW_HAL_LCD_PURPLE);\n" \
						 "    mw_gl_clear_pattern();\n" \
						 "    mw_gl_set_border(MW_GL_BORDER_OFF);\n" \
						 "    mw_gl_set_fill(MW_GL_FILL);\n" \
						 "    mw_gl_rectangle(draw_info, 0, 0, MW_ROOT_WIDTH, MW_ROOT_HEIGHT);\n}\n\n" \
						 "void mw_user_root_message_function(const mw_message_t *message)\n" \
						 "{\n    (void)message;\n}\n\n" \
						 "void mw_user_init(void)\n{\n" \
						 "    mw_util_rect_t r;\n\n";

	// each window's set_rect and mw_add_window
    for (auto& window : json["Windows"].array_items())
    {
    	// check presence and format of required window fields
    	if(!window["X"].is_number())
    	{
    		cout << "No X value for window " << window["Name"].string_value() << endl;
    		exit(1);
    	}
    	if(!window["Y"].is_number())
    	{
    		cout << "No Y value for window " << window["Name"].string_value() << endl;
    		exit(1);
    	}
    	if(!window["Width"].is_number())
    	{
    		cout << "No Width value for window " << window["Name"].string_value() << endl;
    		exit(1);
    	}
    	if(!window["Height"].is_number())
    	{
    		cout << "No Height value for window " << window["Name"].string_value() << endl;
    		exit(1);
    	}
    	// todo more fields to check here
        outfileUserSource << "    mw_util_set_rect(&r, " <<
        		to_string(window["X"].int_value()) << ", " <<
				to_string(window["Y"].int_value()) << ", " <<
				to_string(window["Width"].int_value()) << ", " <<
				to_string(window["Height"].int_value()) << ");\n" \
        		"    window_" << window["Name"].string_value() << "_handle = mw_add_window(&r,\n" \
        		"        \"" << window["Title"].string_value() << "\", \n" \
        		"        window_" << window["Name"].string_value() << "_paint_function,\n" \
				"        window_" << window["Name"].string_value() << "_message_function,\n        ";
        if (window["MenuItems"].array_items().size() == 0)
        {
        	outfileUserSource << "NULL,\n        0,\n        0";
        }
        else
        {
        	outfileUserSource << window["Name"].string_value() << "_menu_bar_labels" \
				",\n        sizeof(" << window["Name"].string_value() << "_menu_bar_labels)/sizeof(char *),\n        0"; 
        }
				
		if (window["Border"].bool_value())
		{
			outfileUserSource << " | MW_WINDOW_FLAG_HAS_BORDER";
		}
		if (window["TitleBar"].bool_value())
		{
			outfileUserSource << " | MW_WINDOW_FLAG_HAS_TITLE_BAR";
		}		
		if (window["CanClose"].bool_value())
		{
			outfileUserSource << " | MW_WINDOW_FLAG_CAN_BE_CLOSED";
		}		
		if (window["VerticalScrollBarEnabled"].bool_value())
		{
			outfileUserSource << " | MW_WINDOW_FLAG_VERT_SCROLL_BAR_ENABLED";
		}	
		if (window["HorizontalScrollBarEnabled"].bool_value())
		{
			outfileUserSource << " | MW_WINDOW_FLAG_HORIZ_SCROLL_BAR_ENABLED";
		}			
		if (window["VerticalScrollBar"].bool_value())
		{
			outfileUserSource << " | MW_WINDOW_FLAG_HAS_VERT_SCROLL_BAR";
		}	
		if (window["HorizontalScrollBar"].bool_value())
		{
			outfileUserSource << " | MW_WINDOW_FLAG_HAS_HORIZ_SCROLL_BAR";
		}		
		if (window["MenuBar"].bool_value())
		{
			outfileUserSource << " | MW_WINDOW_FLAG_HAS_MENU_BAR";
		}			
		if (window["MenuBarEnabled"].bool_value())
		{
			outfileUserSource << " | MW_WINDOW_FLAG_MENU_BAR_ENABLED";
		}		
		if (window["Visible"].bool_value())
		{
			outfileUserSource << " | MW_WINDOW_FLAG_IS_VISIBLE";
		}	
		if (window["Minimised"].bool_value())
		{
			outfileUserSource << " | MW_WINDOW_FLAG_IS_MINIMISED";
		}	
		if (large_size)
		{
			outfileUserSource << " | MW_WINDOW_FLAG_LARGE_SIZE";
		}							
		outfileUserSource << ",\n        NULL);\n";
        outfileUserSource << "\n";
        
        // create buttons
		for (auto& button : window["Buttons"].array_items())
		{
			outfileUserSource << "    mw_util_safe_strcpy(button_" << button["Name"].string_value() << "_data.button_label, MW_UI_BUTTON_LABEL_MAX_CHARS, \"" <<
				button["Label"].string_value() << "\");\n";
			outfileUserSource << "    button_" << button["Name"].string_value() << "_handle = mw_ui_button_add_new(" << button["X"].int_value() << ",\n" \
				"        " << button["Y"].int_value() << ",\n" \
			    "        window_" << window["Name"].string_value() << "_handle,\n" \
			    "        0";
			if (button["Visible"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_VISIBLE";
			}	
			if (button["Enabled"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_ENABLED";
			}			
			if (large_size)
			{
				outfileUserSource << " | MW_CONTROL_FLAG_LARGE_SIZE";
			}	  
			outfileUserSource << ",\n" \
			    "        &button_" << button["Name"].string_value() << "_data);\n\n"; 	
		}
		
        // create labels
		for (auto& label : window["Labels"].array_items())
		{
			outfileUserSource << "    mw_util_safe_strcpy(label_" << label["Name"].string_value() << "_data.label, MW_UI_LABEL_MAX_CHARS, \"" <<
				label["Label"].string_value() << "\");\n";
			outfileUserSource << "    label_" << label["Name"].string_value() << "_handle = mw_ui_label_add_new(" << label["X"].int_value() << ",\n" \
				"        " << label["Y"].int_value() << ",\n" \
				"        " << label["Width"].int_value() << ",\n" \
			    "        window_" << window["Name"].string_value() << "_handle,\n" \
			    "        0";
			if (label["Visible"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_VISIBLE";
			}	
			if (label["Enabled"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_ENABLED";
			}			
			if (large_size)
			{
				outfileUserSource << " | MW_CONTROL_FLAG_LARGE_SIZE";
			}	  
			outfileUserSource << ",\n" \
			    "        &label_" << label["Name"].string_value() << "_data);\n\n"; 	
		}		
		
        // create check boxes
		for (auto& check_box : window["CheckBoxes"].array_items())
		{
			outfileUserSource << "    mw_util_safe_strcpy(check_box_" << check_box["Name"].string_value() << "_data.label, MW_UI_CHECK_BOX_LABEL_MAX_CHARS, \"" <<
				check_box["Label"].string_value() << "\");\n";
			outfileUserSource << "    check_box_" << check_box["Name"].string_value() << "_handle = mw_ui_check_box_add_new(" << check_box["X"].int_value() << ",\n" \
				"        " << check_box["Y"].int_value() << ",\n" \
			    "        window_" << window["Name"].string_value() << "_handle,\n" \
			    "        0";
			if (check_box["Visible"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_VISIBLE";
			}	
			if (check_box["Enabled"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_ENABLED";
			}			
			if (large_size)
			{
				outfileUserSource << " | MW_CONTROL_FLAG_LARGE_SIZE";
			}	  
			outfileUserSource << ",\n" \
			    "        &check_box_" << check_box["Name"].string_value() << "_data);\n\n"; 	
		}		
		
        // create arrows
		for (auto& arrow : window["Arrows"].array_items())
		{				
			outfileUserSource << "    arrow_" << arrow["Name"].string_value() << "_data.mw_ui_arrow_direction = MW_UI_ARROW_";
			auto& f = std::use_facet<std::ctype<char>>(std::locale());
			f.toupper(const_cast<char *>(arrow["Direction"].string_value().data()), arrow["Direction"].string_value().data() + arrow["Direction"].string_value().size());			
			outfileUserSource << arrow["Direction"].string_value() << ";\n";
			outfileUserSource << "    arrow_" << arrow["Name"].string_value() << "_handle = mw_ui_arrow_add_new(" << arrow["X"].int_value() << ",\n" \
				"        " << arrow["Y"].int_value() << ",\n" \
			    "        window_" << window["Name"].string_value() << "_handle,\n" \
			    "        0";
			if (arrow["Visible"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_VISIBLE";
			}	
			if (arrow["Enabled"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_ENABLED";
			}			
			if (large_size)
			{
				outfileUserSource << " | MW_CONTROL_FLAG_LARGE_SIZE";
			}	  
			outfileUserSource << ",\n" \
			    "        &arrow_" << arrow["Name"].string_value() << "_data);\n\n"; 	
		}	
		
        // create progress bars
		for (auto& progress_bar : window["ProgressBars"].array_items())
		{
			outfileUserSource << "    progress_bar_" << progress_bar["Name"].string_value() << "_handle = mw_ui_progress_bar_add_new(" << progress_bar["X"].int_value() << ",\n" \
				"        " << progress_bar["Y"].int_value() << ",\n" \
				"        " << progress_bar["Width"].int_value() << ",\n" \
				"        " << progress_bar["Height"].int_value() << ",\n" \
			    "        window_" << window["Name"].string_value() << "_handle,\n" \
			    "        0";
			if (progress_bar["Visible"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_VISIBLE";
			}	
			if (progress_bar["Enabled"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_ENABLED";
			}			
			if (large_size)
			{
				outfileUserSource << " | MW_CONTROL_FLAG_LARGE_SIZE";
			}	  
			outfileUserSource << ",\n" \
			    "        &progress_bar_" << progress_bar["Name"].string_value() << "_data);\n\n"; 	
		}		

		// create horiz scroll bars
		for (auto& scroll_bar_horiz : window["HorizScrollBars"].array_items())
		{
			outfileUserSource << "    scroll_bar_horiz_" << scroll_bar_horiz["Name"].string_value() << "_handle = mw_ui_scroll_bar_horiz_add_new(" << scroll_bar_horiz["X"].int_value() << ",\n" \
				"        " << scroll_bar_horiz["Y"].int_value() << ",\n" \
				"        " << scroll_bar_horiz["Width"].int_value() << ",\n" \
			    "        window_" << window["Name"].string_value() << "_handle,\n" \
			    "        0";
			if (scroll_bar_horiz["Visible"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_VISIBLE";
			}	
			if (scroll_bar_horiz["Enabled"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_ENABLED";
			}			
			if (large_size)
			{
				outfileUserSource << " | MW_CONTROL_FLAG_LARGE_SIZE";
			}	  
			outfileUserSource << ",\n" \
			    "        &scroll_bar_horiz_" << scroll_bar_horiz["Name"].string_value() << "_data);\n\n"; 	
		}	
		
		// create vert scroll bars
		for (auto& scroll_bar_vert : window["VertScrollBars"].array_items())
		{
			outfileUserSource << "    scroll_bar_vert_" << scroll_bar_vert["Name"].string_value() << "_handle = mw_ui_scroll_bar_vert_add_new(" << scroll_bar_vert["X"].int_value() << ",\n" \
				"        " << scroll_bar_vert["Y"].int_value() << ",\n" \
				"        " << scroll_bar_vert["Height"].int_value() << ",\n" \
			    "        window_" << window["Name"].string_value() << "_handle,\n" \
			    "        0";
			if (scroll_bar_vert["Visible"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_VISIBLE";
			}	
			if (scroll_bar_vert["Enabled"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_ENABLED";
			}			
			if (large_size)
			{
				outfileUserSource << " | MW_CONTROL_FLAG_LARGE_SIZE";
			}	  
			outfileUserSource << ",\n" \
			    "        &scroll_bar_vert_" << scroll_bar_vert["Name"].string_value() << "_data);\n\n"; 	
		}		
		
		// create radio buttons
		for (auto& radio_button : window["RadioButtons"].array_items())
		{
			outfileUserSource << "    radio_button_" << radio_button["Name"].string_value() << "_data.number_of_items = (sizeof(radio_button_" << 
				radio_button["Name"].string_value() << "_labels)/sizeof(char *));\n";
			outfileUserSource << "    radio_button_" << radio_button["Name"].string_value() << "_data.radio_button_labels = radio_button_" << 
				radio_button["Name"].string_value() << "_labels;\n";
			outfileUserSource << "    radio_button_" << radio_button["Name"].string_value() << "_handle = mw_ui_radio_button_add_new(" << radio_button["X"].int_value() << ",\n" \
				"        " << radio_button["Y"].int_value() << ",\n" \
				"        " << radio_button["Width"].int_value() << ",\n" \
			    "        window_" << window["Name"].string_value() << "_handle,\n" \
			    "        0";
			if (radio_button["Visible"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_VISIBLE";
			}	
			if (radio_button["Enabled"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_ENABLED";
			}			
			if (large_size)
			{
				outfileUserSource << " | MW_CONTROL_FLAG_LARGE_SIZE";
			}	  
			outfileUserSource << ",\n" \
			    "        &radio_button_" << radio_button["Name"].string_value() << "_data);\n\n"; 	
		}			
		
		// create list boxes
		for (auto& list_box : window["ListBoxes"].array_items())
		{
			outfileUserSource << "    list_box_" << list_box["Name"].string_value() << "_data.line_enables = MW_ALL_ITEMS_ENABLED;\n";
			outfileUserSource << "    list_box_" << list_box["Name"].string_value() << "_data.number_of_lines = " << list_box["Lines"].int_value() << ";\n";
			outfileUserSource << "    list_box_" << list_box["Name"].string_value() << "_data.number_of_items = (sizeof(list_box_" << 
				list_box["Name"].string_value() << "_entries)/sizeof(mw_ui_list_box_entry));\n";
			outfileUserSource << "    list_box_" << list_box["Name"].string_value() << "_data.list_box_entries = list_box_" << 
				list_box["Name"].string_value() << "_entries;\n";
			outfileUserSource << "    list_box_" << list_box["Name"].string_value() << "_handle = mw_ui_list_box_add_new(" << list_box["X"].int_value() << ",\n" \
				"        " << list_box["Y"].int_value() << ",\n" \
				"        " << list_box["Width"].int_value() << ",\n" \
			    "        window_" << window["Name"].string_value() << "_handle,\n" \
			    "        0";
			if (list_box["Visible"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_VISIBLE";
			}	
			if (list_box["Enabled"].bool_value())
			{
				outfileUserSource << " | MW_CONTROL_FLAG_IS_ENABLED";
			}			
			if (large_size)
			{
				outfileUserSource << " | MW_CONTROL_FLAG_LARGE_SIZE";
			}	  
			outfileUserSource << ",\n" \
			    "        &list_box_" << list_box["Name"].string_value() << "_data);\n\n"; 	
		}						
    }

    outfileUserSource << "    mw_paint_all();\n}\n";
    outfileUserSource.close();

	// create window .c and .h files
    for (auto &window : json["Windows"].array_items())
    {
    	string windowName = window["Name"].string_value();
    	std::ofstream outfileWindowSource("generated/common/" + windowName + ".c");
    	if (!outfileWindowSource.is_open())
    	{
    		cout << "Could not create file\n";
    		exit(1);
    	}
    	outfileWindowSource << "/* " << windowName + ".c generated by MiniWin code generator. */\n\n" \
					"#include \"miniwin.h\"\n\n";
    	outfileWindowSource << "typedef struct\n{    /* Add your data members here */\n} window_" << windowName << "_data_t;\n\n";
    	outfileWindowSource << "static window_" << windowName << "_data_t window_" << windowName << "_data;\n\n";
    	outfileWindowSource << "void window_" << windowName << "_paint_function(mw_handle_t window_handle, const mw_gl_draw_info_t *draw_info)\n" \
    				"{\n    MW_ASSERT(draw_info, \"Null pointer parameter\");\n\n" \
					"    mw_gl_set_fill(MW_GL_FILL);\n" \
					"    mw_gl_set_solid_fill_colour(MW_HAL_LCD_WHITE);\n" \
					"    mw_gl_set_border(MW_GL_BORDER_OFF);\n" \
					"    mw_gl_clear_pattern();\n" \
					"    mw_gl_rectangle(draw_info,\n" \
					"        0, 0,\n" \
					"        mw_get_window_client_rect(window_handle).width,\n" \
					"        mw_get_window_client_rect(window_handle).height);\n\n" \
					"    /* Add you window painting code here */\n\n}\n";
    	outfileWindowSource << "void window_" << windowName << "_message_function(const mw_message_t *message)\n" \
       				"{\n    MW_ASSERT(message, \"Null pointer parameter\");\n\n" \
       	            "    /* Next line stops compiler warnings as variable is currently unused */\n";
    	outfileWindowSource << "    (void)window_" << windowName << "_data;\n\n" \
       				"    switch (message->message_id)\n" \
					"    {\n"\
       				"    case MW_WINDOW_CREATED_MESSAGE:\n" \
       				"        break;\n\n" \
       				"    /* Add you message handlers here */\n\n" \
					"    default:\n" \
					"        break;\n    }\n}\n";
    	outfileWindowSource.close();

    	std::ofstream outfileWindowHeader("generated/common/" + windowName + ".h");
    	if (!outfileWindowHeader.is_open())
    	{
    		cout << "Could not create file\n";
    		exit(1);
    	}
    	outfileWindowHeader << "/* " << windowName + ".h generated by MiniWin code generator. */\n\n";
    	outfileWindowHeader << "#ifndef _WINDOW_" << windowName << "_H\n" \
    			   "#define _WINDOW_" << windowName << "_H\n\n" \
				   "#include \"miniwin.h\"\n\n" \
				   "void window_" << windowName << "_paint_function(mw_handle_t window_handle, const mw_gl_draw_info_t *draw_info);\n\n" \
				   "void window_" << windowName << "_message_function(const mw_message_t *message);\n\n" \
				   "#endif\n";

    	outfileWindowHeader.close();
    }

    // create main.c
	std::ofstream outfileMainSource("generated/common/main.c");
	if (!outfileMainSource.is_open())
	{
		cout << "Could not create file\n";
		exit(1);
	}
	outfileMainSource << "/* main.c generated by MiniWin code generator. */\n\n" \
			"#include \"miniwin.h\"\n" \
			"#include \"app.h\"\n\n" \
			"int main(void)\n" \
			"{\n" \
			"    app_init();\n" \
			"    mw_init();\n\n" \
			"    while(true)\n" \
		    "    {\n" \
			"        app_main_loop_process();\n" \
			"        mw_process_message();\n" \
			"    }\n" \
			"}\n";
	outfileMainSource.close();

    // create app.c
	std::ofstream outfileAppSource("generated/" + json["TargetType"].string_value() + "/src/app.c");
	if (!outfileAppSource.is_open())
	{
		cout << "Could not create file\n";
		exit(1);
	}

	if (json["TargetType"].string_value() == "Windows")
	{
	outfileAppSource <<
			"/* app.c generated by MiniWin code generator. */\n\n" \
			"void app_init(void)\n" \
			"{\n" \
			"}\n\n" \
			"void app_main_loop_process(void)\n" \
			"{\n" \
			"}\n";
	}
	else if (json["TargetType"].string_value() == "Linux")
	{
		outfileAppSource <<
			"/* app.c generated by MiniWin code generator. */\n\n" \
			"#include <X11/Xlib.h>\n\n" \
			"Display *display;\n" \
			"Window frame_window;\n" \
			"GC graphical_context;\n\n" \
			"void app_init(void)\n" \
			"{\n" \
			"    static	Visual *visual;\n" \
			"    static int depth;\n" \
			"    static XSetWindowAttributes frame_attributes;\n\n" \
			"    display = XOpenDisplay(NULL);\n" \
			"    visual = DefaultVisual(display, 0);\n" \
			"    depth  = DefaultDepth(display, 0);\n\n" \
			"    frame_attributes.background_pixel = XBlackPixel(display, 0);\n\n" \
			"    frame_window = XCreateWindow(display,\n" \
			"        XRootWindow(display, 0),\n" \
			"        0,\n" \
			"        0,\n" \
			"        260,\n" \
			"        320,\n" \
			"        5,\n" \
			"        depth,\n" \
			"        InputOutput,\n" \
			"        visual,\n" \
			"        CWBackPixel,\n" \
			"        &frame_attributes);\n" \
			"    XSelectInput(display, frame_window, ExposureMask | StructureNotifyMask);\n\n" \
			"    graphical_context = XCreateGC( display, frame_window, 0, 0 );\n\n" \
			"    XMapWindow(display, frame_window);\n" \
			"    XFlush(display);\n" \
			"}\n\n" \
			"void app_main_loop_process(void)\n" \
			"{\n" \
			"}\n";
	}
	outfileAppSource.close();

    // create app.h
	std::ofstream outfileAppHeader("generated/" + json["TargetType"].string_value() + "/src/app.h");
	if (!outfileAppHeader.is_open())
	{
		cout << "Could not create file\n";
		exit(1);
	}
	outfileAppHeader <<
			"/* app.h generated by MiniWin code generator. */\n\n" \
			"#ifndef _APP_H\n" \
			"#define _APP_H\n\n" \
			"#ifdef __cplusplus\n extern \"C\" {\n" \
			"#endif\n\n" \
			"void app_init(void);\n" \
			"void app_main_loop_process(void);\n\n" \
			"#ifdef __cplusplus\n}\n" \
			"#endif\n\n" \
			"#endif\n";
	outfileAppHeader.close();

	// create makefile
	std::ofstream outfileMake("generated/" + json["TargetType"].string_value() + "/makefile");
	if (!outfileMake.is_open())
	{
		cout << "Could not create file\n";
		exit(1);
	}
	outfileMake << "BINARY = " << json["TargetName"].string_value();

	if (json["TargetType"].string_value() == "Windows")
	{
		outfileMake << ".exe\n\n";
	}
	else if (json["TargetType"].string_value() == "Linux")
	{
		outfileMake << "\n\n";
	}

	outfileMake <<
			"SRCS := $(wildcard src/*.c) \\\n" \
			"	$(wildcard ../common/*.c) \\\n" \
			"	$(wildcard ../../MiniWin/*.c) \\\n" \
			"	$(wildcard ../../MiniWin/bitmaps/*.c) \\\n" \
			"	$(wildcard ../../MiniWin/hal/*.c) \\\n";
	if (json["TargetType"].string_value() == "Windows")
	{
		outfileMake << "	$(wildcard ../../MiniWin/hal/windows/*.c) \\\n";
	}
	else if (json["TargetType"].string_value() == "Linux")
	{
		outfileMake << "	$(wildcard ../../MiniWin/hal/linux/*.c) \\\n";
	}
	outfileMake <<
			"	$(wildcard ../../MiniWin/ui/*.c) \\\n" \
			"	$(wildcard ../../MiniWin/dialogs/*.c) \\\n" \
			"	$(wildcard ../../MiniWin/gl/*.c) \\\n" \
			"	$(wildcard ../../MiniWin/gl/fonts/bitmapped/*.c) \\\n" \
			"	$(wildcard ../../MiniWin/gl/fonts/truetype/*.c) \\\n" \
			"	$(wildcard ../../MiniWin/gl/fonts/truetype/mcufont/*.c)\n\n" \
			"CC = gcc\n" \
			"CFLAGS = -I../../MiniWin -I../../MiniWin/gl/fonts/truetype/mcufont -Isrc -I../common -g -Wall\n" \
			"OBJECTS := $(SRCS:.c=.o)\n";

	if (json["TargetType"].string_value() == "Windows")
	{
		outfileMake << "LIBS = -lgdi32\n\n";
	}
	else if (json["TargetType"].string_value() == "Linux")
	{
		outfileMake << "LIBS = -lX11 -lm -lpthread\n\n";
	}

	outfileMake << "all: ${OBJECTS}\n" \
	"	${CC} $(CFLAGS) ${OBJECTS} ${LIBS} -o ${BINARY}\n\n" \
	"clean:\n" \
	"	rm $(OBJECTS)\n" \
	"	rm ${BINARY}\n";

	// display identifer names
	cout << "Created the following identifiers...\n\n";
	for (auto& identifier : all_identifier_names)
	{
		cout << identifier << endl;
	}

	// check duplicate identifier names
	for (uint32_t i = 0; i < all_identifier_names.size(); i++)
	{
		auto identifier = all_identifier_names.at(i);

		for (uint32_t j = i + 1; j < all_identifier_names.size(); j++)
		{
			if (identifier == all_identifier_names.at(j))
			{
				cout << "\nDuplicate identifier found: " << identifier << endl;
				exit(1);
			}
		}

	}

	cout << "\nGeneration completed successfully.\n";
	outfileMake.close();
}
